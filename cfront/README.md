# cfront

## Project setup
```
npm install
```

### Compiles and hot-reloads for development
```
npm run serve
```

### Compiles and minifies for production
```
npm run build
```

### Customize configuration
See [Configuration Reference](https://cli.vuejs.org/config/).


npm install @vue/cli

npm install axios 

npm install qs @vue/cli element-ui js-md5

npm install element-ui js-md5

npm install js-md5




委托终端,它是怎么处理柜台推送过来的数据的, 还有委托终端,它是如何请求行情数据的。
打开委托终端的代码,
委托终端既然想接受这些推送的数据, 那么它肯定是要连到这个Vertx的总线上面的。
要连接总线,就需要安装一个Vertx提供的一个依赖包。
这个依赖包: npm install vue-vertx3-eventbus-client。
接着找到frontConfigure.js。
因为既然要连接总线, 我们就需要提供一个总线的IP,还有端口。这个配置就加在frontConfigure.js里面。
连接的配置像有这样三个内容, 一个是它的IP,一个是端口, 还有一个就是最后的URL。
有了这个连接配置, 我们就可以在委托中端启动的时候去连接这个地址,也就是连接这个WebSocket的总线。
因为是委托终端,一打开就要去连了, 所以我们要把这部分连接的代码放在Main.js里面。
也就是在这个Vue创建的时候,我们需要把EventBus绑定到这个Vue上。
先导入EventBus的依赖, 然后对EventBus指定一些连接的配置。
除了这几项配置, 我们还需要给它默认一个断线重连,就是说,如果因为某种原因, 跟我们网络的连接断开了, 那么它还会自动去重连EventBus。
到了这里, 我们就已经成功的连上了那个柜台给我们提供的总线了
接下来我们要做两件事情。 
一个是处理柜台发过来的委托变动的这样的一个消息，这个消息是主动推送过来的。
另外一个, 就是委托终端(前端)主动的跟柜台去要一些行情数据。

先看第一个,
处理柜台的推送,我们就需要先订阅一些数据。
那这个订阅的逻辑适合放在哪里呢?
因为订阅需要根据用户的ID
去总线上面找一些数据，这个要求我们一定是先登陆成功的。
所以订阅的逻辑就给它放在 Home.vue这个模块里面。
Vertx在这一块给我们做了很好的封装，我们只需要传一个JSON对象进去, 就可以帮我们实现订阅。
这个JSON对象,包括以下几个内容：
第一个,是订阅的地址。
第二个,是订阅的消息头。
第三个,就是对于推送数据处理的一个回调函数。
先来看这个地址。
我们要处理的订阅,它有两种：一个是委托的变动,一个是成交的变动。
根据柜台那边的规范, 对于委托的变动, 我们是用"orderchange-"这个前缀来指定的。
完整的地址就是"orderchange-" + 当前用户的ID。
当我们收到一个委托变动的通知的时候, 我们应该做什么呢?
我们需要把委托、成交、持仓、资金全部都查一遍。
因为这个订阅它只是一个通知, 没有带任何的有用的数据给我们。
为了复用这部分查询更新的逻辑, 我们就主动的调用柜台的一些查询接口,
然后这些接口呢, 也都是在柜台开发的时候做好的接口。
查询的数据包括, 委托、成交、持仓还有资金, 这些全部都要查一遍。
先对这些方法做一个引入。
接着我们再来看, 对于成交的一个通知。
逻辑和上面委托变动的通知是类似的, 只是监听的地址不同,
监听的地址的开头是"tradechange-"。
因为成交这部分的数据,
柜台推给我们一些用来显示的信息了, 所以我们就直接把这部分信息给它展示出来,
另外更新的查询操作会全部在委托里面来做。
成交这里的通知, 就只是做一个展示来用。
要展示一个通知, 我们就需要用到ElementUI的相关的组件,
但是那部分组件呢, 在EventBus的这个callback里面是不可达的,
所以我们通过全局的这个vue, 发一个tradechange的消息出来,
在当前的home.vue里面, 对这个消息做一个监听, 用来处理成交的变动。
这个监听, 在当前的这个home的组件创建出来的时候, 一并把它创建出来。
首先对发过来的消息做一个解析, 然后根据这些消息, 生成一条用来展示的提示。
提示的信息就是, 我在哪支股票上成交了多少股。
到这里, 我们就已经能成功的处理 委托的变动通知 还有 成交的变动通知了。
接着,我们再来看,
行情那部分是怎么跟柜台主动去请求的。
因为最终是要对买入买出, 进行一个演示的,
我们这里先把卖出的界面给它建出来。
通过这个建的过程, 我们再重温一下, 在委托终端的工程里面, 是怎么新建一个页面的。
第一步是添加一个路由(index.js), 添加一个卖委托的路由。
第二步,新建一个委托头的组件。 这个组件可以直接从买委托的这个组件,
给它拷贝出来。 因为我们已经提前写好了, 这里直接把它拷进来。
里面的内容, 和买委托的组件是一模一样的。
只有在direction这个参数上面, 卖委托的组件里面传的全部都是1。
我们找到OrderWidget这个组件,
对其中的一些问题做一个修改。
第一个是颜色这个地方,在CSS的颜色里面, 16进制的颜色, 是要用#来打头的。
第二个,就是遍历的这部分, 有一点小出入。
来回到正题, 看看定栏目是怎么主动来请求行情的。
要请求行情, 我们就得知道, 什么时机去请求行情。
我们认为请求的最佳时机呢, 就是在用户输入完整的股票代码之后,
我们再以固定的频率, 去请求行情数据。
那在什么时机, 表明用户已经选择了一个股票代码呢?
那个时机: 在用户选择 或者 输入一个完整的股票代码的时候
codeinput的那个组件, 会往外发送这样一个事件codeinput-selected。
我们只要监听这个事件, 就能知道用户填完股票代码了。
然后, 我们就可以去柜台, 根据股票代码, 请求具体的行情了。
我们来到订单簿的组件OrderBook.vue。
在创建这个组件的时候, 
我们就需要对code input, 那个自动输入框的一个选择事件,
做一个监听this.$bus.on("codeinput-selected", this.startL1Sub);。
然后在destroy的时候, 把这个监听也给它撤销掉this.$bus.off("codeinput-selected", this.startL1Sub);。
把这个要监听的方法 startL1Sub(item) ,
给它先定义出来。 这个入参, 就是code input那个消息 带过来的一个JSON对象。 
在调用这个方法的时候, 我们就会去柜台,
进行一个定时的请求任务。
先拿到股票代码, 然后根据这个股票代码, 去起一个定时任务。
在JS当中, 我们是通过setInterval去起定时任务的。 
setInterval有两个入参,
第一个是要执行的任务,
第二个就是请求的一个频率。
我们这里指定, 每秒钟刷一次。
当然,在启动这个请求任务的时候, 我们需要每次先给它做一个重置的操作,
因为你有可能当前的 OrderBook的页面里面, 还保留着上一次请求的订单薄的数据。
这里就需要定一个重置数据的, 这样的一个方法。 
重置数据, 它就是要把这个OrderBook里面的数据都给它清空,
然后再根据这个入参确定: 是不是把定时任务也给停掉。
第1步, 是来先把这个订单薄的所有数据, 全给它清空掉。
清空的内容包括: 行情时间, 买单的价和量, 卖单的价和量, 还有那个进度条。
第2步,我们再根据入参确定, 是否要清除这个定时任务。
在这个定时任务里面, 我们就给柜台发一个消息, 请求对应的行情数据。
发数据是直接通过event bus去发的。
发到那个地址, 我们在柜台那边也已经做好了定义。
现在的方法入参,一共有四个。
第一个, 是要发送的地址。
第二个, 是带过去的消息。
第三个,是消息头,在消息头里面,
我们会把股票代码放进去。

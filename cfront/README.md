# cfront

## Project setup
```
npm install
```

### Compiles and hot-reloads for development
```
npm run serve
```

### Compiles and minifies for production
```
npm run build
```

### Customize configuration
See [Configuration Reference](https://cli.vuejs.org/config/).


npm install @vue/cli

npm install axios 

npm install qs @vue/cli element-ui js-md5

npm install element-ui js-md5

npm install js-md5




委托终端,它是怎么处理柜台推送过来的数据的, 还有委托终端,它是如何请求行情数据的。
打开委托终端的代码,
委托终端既然想接受这些推送的数据, 那么它肯定是要连到这个Vertx的总线上面的。
要连接总线,就需要安装一个Vertx提供的一个依赖包。
这个依赖包: npm install vue-vertx3-eventbus-client。
接着找到frontConfigure.js。
因为既然要连接总线, 我们就需要提供一个总线的IP,还有端口。这个配置就加在frontConfigure.js里面。
连接的配置像有这样三个内容, 一个是它的IP,一个是端口, 还有一个就是最后的URL。
有了这个连接配置, 我们就可以在委托中端启动的时候去连接这个地址,也就是连接这个WebSocket的总线。
因为是委托终端,一打开就要去连了, 所以我们要把这部分连接的代码放在Main.js里面。
也就是在这个Vue创建的时候,我们需要把EventBus绑定到这个Vue上。
先导入EventBus的依赖, 然后对EventBus指定一些连接的配置。
除了这几项配置, 我们还需要给它默认一个断线重连,就是说,如果因为某种原因, 跟我们网络的连接断开了, 那么它还会自动去重连EventBus。
到了这里, 我们就已经成功的连上了那个柜台给我们提供的总线了
接下来我们要做两件事情。 
一个是处理柜台发过来的委托变动的这样的一个消息，这个消息是主动推送过来的。
另外一个, 就是委托终端(前端)主动的跟柜台去要一些行情数据。

先看第一个,
处理柜台的推送,我们就需要先订阅一些数据。
那这个订阅的逻辑适合放在哪里呢?
因为订阅需要根据用户的ID
去总线上面找一些数据，这个要求我们一定是先登陆成功的。
所以订阅的逻辑就给它放在 Home.vue这个模块里面。
Vertx在这一块给我们做了很好的封装，我们只需要传一个JSON对象进去, 就可以帮我们实现订阅。
这个JSON对象,包括以下几个内容：
第一个,是订阅的地址。
第二个,是订阅的消息头。
第三个,就是对于推送数据处理的一个回调函数。
先来看这个地址。
我们要处理的订阅,它有两种：一个是委托的变动,一个是成交的变动。
根据柜台那边的规范, 对于委托的变动, 我们是用"orderchange-"这个前缀来指定的。
完整的地址就是"orderchange-" + 当前用户的ID。
当我们收到一个委托变动的通知的时候, 我们应该做什么呢?
我们需要把委托、成交、持仓、资金全部都查一遍。
因为这个订阅它只是一个通知, 没有带任何的有用的数据给我们。
为了复用这部分查询更新的逻辑, 我们就主动的调用柜台的一些查询接口,
然后这些接口呢, 也都是在柜台开发的时候做好的接口。
查询的数据包括, 委托、成交、持仓还有资金, 这些全部都要查一遍。
先对这些方法做一个引入。
接着我们再来看, 对于成交的一个通知。
逻辑和上面委托变动的通知是类似的, 只是监听的地址不同,
监听的地址的开头是"tradechange-"。
因为成交这部分的数据,
柜台推给我们一些用来显示的信息了, 所以我们就直接把这部分信息给它展示出来,
另外更新的查询操作会全部在委托里面来做。
成交这里的通知, 就只是做一个展示来用。
要展示一个通知, 我们就需要用到ElementUI的相关的组件,
但是那部分组件呢, 在EventBus的这个callback里面是不可达的,
所以我们通过全局的这个vue, 发一个tradechange的消息出来,
在当前的home.vue里面, 对这个消息做一个监听, 用来处理成交的变动。
这个监听, 在当前的这个home的组件创建出来的时候, 一并把它创建出来。
首先对发过来的消息做一个解析, 然后根据这些消息, 生成一条用来展示的提示。
提示的信息就是, 我在哪支股票上成交了多少股。
到这里, 我们就已经能成功的处理 委托的变动通知 还有 成交的变动通知了。
接着,我们再来看,
行情那部分是怎么跟柜台主动去请求的。
因为最终是要对买入买出, 进行一个演示的,
我们这里先把卖出的界面给它建出来。
通过这个建的过程, 我们再重温一下, 在委托终端的工程里面, 是怎么新建一个页面的。
第一步是添加一个路由(index.js), 添加一个卖委托的路由。
第二步,新建一个委托头的组件。 这个组件可以直接从买委托的这个组件,
给它拷贝出来。 因为我们已经提前写好了, 这里直接把它拷进来。
里面的内容, 和买委托的组件是一模一样的。
只有在direction这个参数上面, 卖委托的组件里面传的全部都是1。
我们找到OrderWidget这个组件,
对其中的一些问题做一个修改。
第一个是颜色这个地方,在CSS的颜色里面, 16进制的颜色, 是要用#来打头的。
第二个,就是遍历的这部分, 有一点小出入。
来回到正题, 看看定栏目是怎么主动来请求行情的。
要请求行情, 我们就得知道, 什么时机去请求行情。
我们认为请求的最佳时机呢, 就是在用户输入完整的股票代码之后,
我们再以固定的频率, 去请求行情数据。
那在什么时机, 表明用户已经选择了一个股票代码呢?
那个时机: 在用户选择 或者 输入一个完整的股票代码的时候
codeinput的那个组件, 会往外发送这样一个事件codeinput-selected。
我们只要监听这个事件, 就能知道用户填完股票代码了。
然后, 我们就可以去柜台, 根据股票代码, 请求具体的行情了。
我们来到订单簿的组件OrderBook.vue。
在创建这个组件的时候, 
我们就需要对code input, 那个自动输入框的一个选择事件,
做一个监听this.$bus.on("codeinput-selected", this.startL1Sub);。
然后在destroy的时候, 把这个监听也给它撤销掉this.$bus.off("codeinput-selected", this.startL1Sub);。
把这个要监听的方法 startL1Sub(item) ,
给它先定义出来。 这个入参, 就是code input那个消息 带过来的一个JSON对象。 
在调用这个方法的时候, 我们就会去柜台,
进行一个定时的请求任务。
先拿到股票代码, 然后根据这个股票代码, 去起一个定时任务。
在JS当中, 我们是通过setInterval去起定时任务的。 
setInterval有两个入参,
第一个是要执行的任务,
第二个就是请求的一个频率。
我们这里指定, 每秒钟刷一次。
当然,在启动这个请求任务的时候, 我们需要每次先给它做一个重置的操作,
因为你有可能当前的 OrderBook的页面里面, 还保留着上一次请求的订单薄的数据。
这里就需要定一个重置数据的, 这样的一个方法。 
重置数据, 它就是要把这个OrderBook里面的数据都给它清空,
然后再根据这个入参确定: 是不是把定时任务也给停掉。
第1步, 是来先把这个订单薄的所有数据, 全给它清空掉。
清空的内容包括: 行情时间, 买单的价和量, 卖单的价和量, 还有那个进度条。
第2步,我们再根据入参确定, 是否要清除这个定时任务。
在这个定时任务里面, 我们就给柜台发一个消息, 请求对应的行情数据。
发数据是直接通过event bus去发的。
发到那个地址, 我们在柜台那边也已经做好了定义。
现在的方法入参,一共有四个。
第一个, 是要发送的地址。
第二个, 是带过去的消息。
第三个,是消息头,在消息头里面,
我们会把股票代码放进去。




最后一个,是对于response(回报)的处理。
回包需要先判断,是不是成功发送请求了。
如果发送失败了,我们打个日志。
对于成功的回包,我们就要解析其中的数据了。
回来的Json数据,是放在reply的Body字段上面的。
为了严谨,我们这里也加一个空判断。
当然,判断的内容,不仅仅是一个空判断的。
我们还需要处理另外两种情况的判断。
第一种情况,就是我传过去的代码,跟回包的那个代码。
假如我传过去的是平安银行的代码,
他回给我的是万科一的代码,那么就会出大问题。
这个订单部是我们报价的唯一的一个参照,
所以这个判断一定不能少。
只要股票代码不对,那么这个包就要把它丢掉。
接下来还有个判断的,就是对于时间戳的判断。
如果我收到了这个回包里面的行情,
它的时间戳比我当前的订单部里面显示的时间戳还要小。
那就说明你收到了这个行情,还没你展示的行情新,
那肯定只保留最新的。
经过上路这几个判断,如果都没有问题,
就说明我们要开始显示这个五档行情了。
显示之前还是老动作,需要先把旧的数据全都清空掉。
但是这次清空呢,定时任务还是要保留的。
所以我们传了一个false进去。
false的意思就是,只清空数据保留定时任务。
接着,我们就对收到的这个五档行情来做一个遍历,
把它填到订单簿的那些表格里面去。
要填的数据内容呢,其实是有三项的。
这三项分明是,价格，量还有一个进度条的宽度。
因为要显示那个进度条的宽度啊,
所以我们就需要知道最大的那个量是多少。
这里还需要定一个临时变量,把那个最大的量给计算出来。
遍历填值的过程呢,我们就这里直接把已经写好的代码口碑进来。
经过这个 for 循环啊,我们已经把价格还有量都填到订单簿当中去了。
而且也获得了最大的那个量的具体的数值。
然后我们就根据这个具体的数值,在订单簿当中,
把所有的一个进度条的宽度给它做个赋值。
具体的计算方法是这个 for 循环。
订单簿当中,每一行进度条的宽度就是用
当前的这一行,它的委托量buyVolumes[i] 来除以最大的委托量maxBuyVolumes[i] 乘以100。
得到这个百分比啊,就是它需要显示的那个宽度的值。
当前选动的这些代码,就已经完成了所有的买委托,
它的价,量,还有进度条宽度的显示。
卖委托处理方式是一样的,我们也不细敲了,
我们直接把它拷备过来。
买委托和卖委托这部分数据填充的一个唯一的区别,
就是在于这个数组的下标号。
到这里,订单部请求还有显示的逻辑,我们就已经完成了。
为了演示最终的功能, 我们再在查询委托的页面里面,增加一个撤单的按钮。
根据在前面柜台的课程里面, 我们定义的那个开发的顺序,
首先,在orderApi.js 里面增加一个调用后台的接口。
这个接口就是用来调柜台的撤单功能的,
然后回到当日委托的查询页面, 就是orderList。
在这个组件当中, 我们给表格增加一列撤单, 给它一个固定的宽度。
在这列里面,放一个按钮。
当然这个按钮并不是任何时候都显示的, 需要根据一定的逻辑去判断。
这个判断的标准, 就是当前这一行委托的状态。
同时,我们也要给这个按钮增加一个click 事件。
当点击撤单按钮的时候, 我们就执行这一行的这条委托的撤单。
现在我们把这两个方法分别定义出来。
什么情况下要显示撤单按钮呢?
只有两种情况需要显示:
第一个是已经报价的。
第二个是部分成交的委托。
只有这两种情况需要显示撤单的按钮。
这里图个省事, 我们就不去定义场量了。
平时开发的时候, 像这样的数字, 我们是都需要定义成场量的。
不然写个3、写个5在这里, 很容易产生起义。
接着再来处理撤单的逻辑。
其实啊,
只要有这个入参row, 我们完全可以拿到这一行的所有信息。
首先定义一个message。
这个message, 就是在我们撤单的时候,
弹出的一个确认框。
确认的内容, 就是我们是不是要执行这一次的撤单的动作。
确认框在Element UI当中,
也给我们提供了confirm这样一个组件。
我们直接调用它。
confirm组件, 它会给我们提供两个选项,
分别是确定和取消时需要执行的逻辑。
只有当我们在点击确定的时候, 才会走到then这个分支过来。
到这里, 我们就已经完成了 撮合核心跟柜台的交互, 以及柜台跟委托中端这两部分的交互。
代码完成之后, 我们对这一部分的逻辑来做一个演示。
演示的内容就包括, 委托成交撤单行情这些数据, 从撮合核心发到 委托中端这一条线上的所有的逻辑。
我们把所有的模块先启动起来。
我们再来看柜台。
在启动柜台之后,
它会接收错和核心的定时发送的行情数据。



排队机三个节点的启动也没有问题。
并且, 第一个节点已经变成了leader的节点。
现在,我们就登入委托终端。
首先看一看,
买入卖出界面,是不是都能正常地走到。
这一步是没有问题的。
然后, 我们再挂一个买单。
用十块钱的价格, 买一股平安银行。
行情时间还有这个订单簿,
并没有如我们所预期的展示在这里。
这个问题要怎么排查呢?
我们要沿着, 委托订单的数据流的流向,
一步一步地去排查。
首先, 去到凑合核心, 看看这笔单子是不是已经挂进去了。
可以看到, 这笔单子已经挂进去了。
那就说明, 问题是出在了柜台这边。
其实, 刚刚我们就已经看到了, 柜台在这里面, 出现了爆错信息。
爆错的内容是, Ordercommands 为空, 这里有个空指针。
Ordercommands为空, 那就说明,
在委托终端发到柜台的这笔委托, 柜台它没有成功地缓存下来。
委托终端发送的委托,
会调用sendOrder 的这个接口。
因为, 撮合核心已经收到了,
所以我们可以断定, 它已经成功地发出去了。
那么, 问题就出在, 保存委托到缓存的这段代码里面。
vertx, 也就是消息总线, 既然已经发到这个地址了,
那这个地址, 到底有没有接收呢?
找到Match Data 的接收的地方。
我们可以看到,
MatchDataConsumer, 并没有处理这个地址上面的数据。
也就是说, 我们只是往上面发了, 但是没有接收它。
我们给这个eventBus,
新增加一个处理功能,
就是对于这个地址上面, 委托数据的一个缓存的处理。
和对凑合核心的数据的处理一样, 我们在eventBus, 增加一个对于这个地址的, 委托数据的处理。
处理的逻辑, 就是把这里面的字节数组, 给它转成一个orderCommand, 然后直接丢到这个缓存里面去。
这个缓存本质上就是一个Map。
这样, 这个orderCommand 肯定就在这个缓存里面了。
在缓存里面, 那它取到的, 肯定就不是空。
我们再重启一下柜台。
重启完成之后, 重新来到买入股票的页面。
输入股票代码, 点击委托买入。
撮合核心这边没有问题, 正常收到了这笔委托,
并且, 也把MatchData对外做了一个发送。
但是orderCommand还是没有展示内容,
我们来看看柜台那边是否爆错了。
柜台没有爆错, 也成功的缓存了。
那么就说明, 这个问题很有可能是处在了委托终端。
打开控制台, 我们可以看到, 控制台这边爆错了, 而且它在不停的爆。
不停的爆, 就说明, 这个时候定时任务已经是生效的了。
也就是说, 我们已经开始不停的 请求这支股票的出去了。
出错的地方, 在代码的157行,
我们点进去看一下。 是因为我们这个变量,命名有误。
重新保存一下。编译没有问题,
再次打开委托买入的页面,
输入股票代码。 可以看到, 订单簿已经发生了变化了。
但是, 行情时间还是没有显示。
这个问题就比较好排查了。
因为, 既然数据已经都到了界面上了, 那么肯定就是数据显示逻辑的问题。
我们找到orderBook对应的代码。
可以看到, 在这个定时任务里面, 我们并没有对行情Time, 这个字段做一些处理。
我们只要在这个定时任务里面, 把相关的处理加上,
显示, 应该就不成问题了。
重新编影没有问题,
我们再回到页面上,
输入股票代码。
输入完成之后,
行情时间也正常的显示了。
并且, 它随着撮合核心发布的那个行情的时间,再进行刷新。
那么, 到这里,委托, 就是没有问题的了。
然后, 我们再来看撤单。
撤单, 要在当日委托的查询页面里面进行。
找到这一笔委托, 点击撤单, 会弹出一个提示框, 问你, 是不是要真的执行撤单指令?
我们点确定。
现在有一个有意思的现象, 就是我们在点了撤单之后, 这条数据是没有变化的。
刚刚, 在点了刷新之后, 才把这条数据给它刷出来。
也就是说,
在撮合核心那边, 已经正常的撤单了,
柜台也把这笔委托状态的变化给落下来了。
但是, 委托中端没有收到通知,
没有收到通知, 就说明,
订阅的逻辑有问题。
在登陆进来的时候,
我们会收到一个这样的曝错。
acess denied,
也就是拒绝访问。
那么, 就是在柜台那边, 对于要访问的地址, 权限设置出了问题。
我们找到这块代码。
柜台里面是通过,
bridgeOptions,
对于这个Vertx的 websocket的总线,做了设置。
可以看到,
它允许进入的地址,
是trade change 或者order change,
作为前缀的这样一个地址。
但是, 我们来看委托中端。
在委托中端这边, 它订阅的消息的地址, 是orderchange-,还加上自己的账户ID了。
所以, 是订阅地址不对, 导致的数据,
没有办法通知给委托中端。
我们给这个正则表达式, 改成一个正确的配置。
因为后面是一个UID, 也就是说, 后面是一串数字,
我们就给这个正则表达式, 增加一个, 或多个数字这样的配置。
这样修改之后的正则表达式, 才符合委托中端订阅的那个地址的格式。
我们把柜台直接重启一下, 把数据清空, 再重新演示一下这个撤单, 看是不是能正确的通知到委托终端。
重新登录进来, 做一个买单。
订单簿没有问题。
这里的订单状态, 目前是已报, 也是没有问题的。
我们点击撤单。过了一会儿, 这笔撤单,已经成功的撤回了。
而且, 这行的变化, 是自动发生的。
也就是说, 柜台给委托中端的推送已经生效了。
接着, 我们再来演示一下成交。
因为是成交,
我们就需要两个中端。
我们再登录另外一个
10555的中端。
登录之后,
我们是这样来测试这个功能的。
用046的账户做买,
用555的账户做卖。
首先, 先挂一笔买单,
然后来到555的账户。 用它的账户做一笔卖单,
可以看出, 右下角给出了新成交的提示。
成交了两股之后, 剩下的四股,
依旧挂在来卖衣裳。
是这样, 成交也是没有问题的。
到这里, 撮合核心, 跟柜台的交互, 还有柜台和委托中端数据的交互两部分,
就已经全部完成了。
这也表示, 我们整个课程的代码的开发,
已经全部结束了。
感谢大家的观看和支持,
我们下节课再见了。

